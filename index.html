<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Whisper Emotion Analyzer</title>
    <style>
        :root {
            --primary: #6a67ce;
            --primary-dark: #5552b9;
            --secondary: #39c4ac;
            --warning: #ffab4c;
            --danger: #f25767;
            --light: #f5f5fa;
            --dark: #2d3142;
            --gray: #888da8;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            padding: 15px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px 0;
            border-bottom: 1px solid #eee;
            position: relative;
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 5px;
            font-size: clamp(1.6rem, 5vw, 2.5rem);
        }
        
        .tagline {
            color: var(--gray);
            font-size: clamp(0.9rem, 3vw, 1.2rem);
        }
        
        .user-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }
        
        @media (min-width: 768px) {
            .user-header {
                position: absolute;
                top: 20px;
                right: 10px;
                margin-top: 0;
            }
        }
        
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
        }
        
        .user-name {
            font-weight: bold;
            color: var(--dark);
        }
        
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: clamp(15px, 5vw, 25px);
            margin-bottom: 30px;
        }
        
        .card-title {
            color: var(--primary);
            margin-bottom: 20px;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        .tabs::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-right: 5px;
            font-weight: bold;
            white-space: nowrap;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        
        .tab.active {
            border-bottom: 3px solid var(--primary);
            color: var(--primary);
        }
        
        .tab-content {
            display: none;
            padding: 15px 0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Voice Recording Styles */
        .voice-recorder {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
        }
        
        .visualizer {
            width: 100%;
            height: 80px;
            background-color: var(--light);
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
            display: block !important;
        }
        
        .timer {
            font-size: clamp(1.8rem, 6vw, 2.5rem);
            font-weight: bold;
            margin: 15px 0;
            color: var(--primary);
        }
        
        .record-buttons {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .record-btn {
            width: 60px !important;
            height: 60px !important;
            border-radius: 50% !important;
            background-color: var(--danger) !important;
            border: none !important;
            cursor: pointer !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            -webkit-tap-highlight-color: transparent;
        }
        
        @media (min-width: 768px) {
            .record-btn {
                width: 70px !important;
                height: 70px !important;
            }
        }
        
        .record-btn:hover {
            transform: scale(1.05);
        }
        
        .record-btn .icon {
            width: 22px;
            height: 22px;
            background-color: white;
            border-radius: 50%;
        }
        
        .record-btn.stop {
            background-color: var(--dark) !important;
        }
        
        .record-btn.stop .icon {
            width: 18px;
            height: 18px;
            background-color: white;
            border-radius: 0;
        }
        
        .record-status {
            margin: 15px 0;
            font-style: italic;
            color: var(--gray);
            text-align: center;
        }
        
        .audio-player {
            width: 100%;
            margin: 20px 0;
            display: none;
        }
        
        /* File Upload Styles */
        .file-upload {
            border: 2px dashed #ccc !important;
            border-radius: 8px !important;
            padding: clamp(20px, 5vw, 40px) !important;
            text-align: center !important;
            margin: 20px 0 !important;
            transition: all 0.3s ease;
            display: block !important;
        }
        
        .file-upload:hover {
            border-color: var(--primary);
        }
        
        .file-label {
            display: block;
            margin-bottom: 15px;
            color: var(--primary);
            font-weight: bold;
            cursor: pointer;
        }
        
        .file-input {
            display: none;
        }
        
        .file-name {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--gray);
            word-break: break-all;
        }
        
        /* Button Styles */
        .btn {
            padding: 10px 20px !important;
            background-color: var(--primary) !important;
            color: white !important;
            border: none !important;
            border-radius: 5px !important;
            font-size: 1rem !important;
            font-weight: bold !important;
            cursor: pointer !important;
            transition: all 0.3s ease;
            margin: 10px 0;
            display: inline-block !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .btn:disabled {
            background-color: #ccc !important;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-secondary {
            background-color: var(--secondary) !important;
        }
        
        .btn-danger {
            background-color: var(--danger) !important;
        }
        
        /* Results Styles */
        .results {
            display: none;
            margin-top: 20px;
        }
        
        .result-item {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
        }
        
        @media (min-width: 768px) {
            .result-item {
                flex-direction: row;
            }
        }
        
        .result-label {
            font-weight: bold;
            width: 100%;
            color: var(--gray);
            margin-bottom: 5px;
        }
        
        @media (min-width: 768px) {
            .result-label {
                width: 140px;
                margin-bottom: 0;
            }
        }
        
        .stress-high {
            color: var(--danger);
            font-weight: bold;
        }
        
        .stress-medium {
            color: var(--warning);
            font-weight: bold;
        }
        
        .stress-low {
            color: var(--secondary);
            font-weight: bold;
        }
        
        .recommendation-box {
            background-color: var(--light);
            border-left: 4px solid var(--primary);
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }
        
        .recommendation-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        /* Loading Spinner */
        .loading {
            display: none;
            text-align: center;
            margin: 30px 0;
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid var(--primary);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Emotion Chart */
        .emotion-chart-container {
            margin-top: 20px;
            height: 250px;
            max-width: 100%;
            overflow: hidden;
        }
        
        /* About Section */
        .about-section {
            margin-top: 30px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .about-title {
            color: var(--primary);
            margin-bottom: 15px;
        }
        
        .emotions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .emotion-tag {
            background-color: var(--light);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            color: var(--dark);
            transition: all 0.3s ease;
        }
        
        .emotion-tag:hover {
            background-color: var(--primary);
            color: white;
            transform: translateY(-2px);
        }
        
        /* Security warning */
        .security-warning {
            background-color: #ffebee;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
            font-size: 0.9rem;
        }
        
        /* Profile & Progress Section */
        .profile-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .profile-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        @media (min-width: 768px) {
            .profile-avatar {
                width: 100px;
                height: 100px;
                font-size: 40px;
            }
        }
        
        .profile-name {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .profile-stats {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px 20px;
            border-radius: 8px;
            background-color: var(--light);
            flex: 1;
            min-width: 120px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        /* Auth Forms */
        .auth-form {
            max-width: 400px;
            margin: 0 auto;
            padding: 0 15px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-group input {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 16px;
        }
        
        .form-footer {
            text-align: center;
            margin-top: 20px;
            color: var(--gray);
        }
        
        .form-error {
            color: var(--danger);
            margin-bottom: 15px;
            display: none;
        }
        
        /* History Section */
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.85rem;
        }
        
        @media (min-width: 768px) {
            .history-table {
                font-size: 1rem;
            }
        }
        
        .history-table th,
        .history-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .history-table th {
            background-color: var(--light);
            font-weight: bold;
            color: var(--dark);
        }
        
        .history-table tr:hover {
            background-color: #f9f9f9;
        }
        
        .history-emotion {
            font-weight: bold;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .pagination-btn {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            background-color: white;
            font-size: 0.9rem;
            min-width: 35px;
            -webkit-tap-highlight-color: transparent;
        }
        
        .pagination-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .chart-container {
            height: 300px;
            margin: 20px 0;
            max-width: 100%;
            overflow: hidden;
        }
        
        .progress-filters {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            background-color: white;
            font-size: 0.9rem;
            -webkit-tap-highlight-color: transparent;
        }
        
        .filter-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid #eee;
            color: var(--gray);
            font-size: 0.9rem;
        }
    </style>
    <!-- Include Chart.js for emotion probability visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- TensorFlow.js for face detection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://unpkg.com/@tensorflow-models/blazeface@2.0.5/dist/blazeface.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>StressBuster AI</h1>
            
            <!-- User info (shown when logged in) -->
            <div class="user-header" id="user-header" style="display: none;">
                <div class="user-avatar" id="user-avatar">A</div>
                <span class="user-name" id="user-name">Anonymous</span>
            </div>
        </header>

        <div class="card">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('analyze')">Analyze Voice</div>
                <div class="tab" onclick="switchTab('about')">About</div>
            </div>
            
            <div id="security-warning" class="security-warning"></div>
            
            <!-- Analyze Voice Tab -->
            <div id="analyze-tab" class="tab-content active">
                <h2 class="card-title">Analyze Your Voice</h2>
                <div id="live-sensors" class="recommendation-box" style="margin-bottom: 15px;">
                <div class="recommendation-title">Live Sensors</div>
                <div style="display:flex; gap:15px; flex-wrap:wrap;">
                <div>Heart Rate: <strong id="heartRate">–</strong> bpm</div>
                 <div>Temperature: <strong id="tempF">–</strong> °C</div>
                 <div>Light: <strong id="light">–</strong></div>
                 <div>Sound: <strong id="sound">–</strong> dB</div>
                 <div id="face-emotion-box" style="
    margin-top: 20px;
    width: 100%;
    max-width: 350px;
    padding: 20px;
    border: 2px solid var(--primary);
    border-radius: 12px;
    background: white;
    box-shadow: 0 4px 12px rgba(106, 103, 206, 0.2);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
">
    <h3 style="margin: 0; color: var(--primary); font-size: 1.1rem; text-align: center;">Facial Emotion Detection</h3>

    <!-- Camera Preview with Face Detection Overlay -->
    <div style="position: relative; display: inline-block;">
        <video id="camera-stream" width="280" height="280" autoplay playsinline style="
            border-radius: 12px;
            border: 3px solid var(--primary);
            background: #000;
            object-fit: cover;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transform: scaleX(-1); /* Mirror for better UX */
        "></video>
        <canvas id="face-detection-canvas" width="280" height="280" style="
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 12px;
            pointer-events: none;
            transform: scaleX(-1); /* Mirror to match video */
        "></canvas>
        <div id="face-detection-status" style="
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(106, 103, 206, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: bold;
            display: none;
        ">Face Detected</div>
    </div>

    <!-- Real-time Emotion Display Box -->
    <div id="face-info" style="
        width: 100%;
        padding: 15px;
        background: linear-gradient(135deg, var(--light) 0%, #ffffff 100%);
        border-radius: 10px;
        border: 2px solid var(--primary);
        display: flex;
        flex-direction: column;
        gap: 10px;
        text-align: center;
    ">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #e0e0e0;">
            <strong style="color: var(--dark);">Emotion:</strong>
            <span id="face-emotion-label" style="font-weight: bold; color: var(--primary); font-size: 1.1rem; text-transform: capitalize;">No Face</span>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #e0e0e0;">
            <strong style="color: var(--dark);">Confidence:</strong>
            <span id="face-emotion-confidence" style="font-weight: bold; color: var(--secondary); font-size: 1.1rem;">--</span>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0;">
            <strong style="color: var(--dark);">Last Update:</strong>
            <span id="face-emotion-ts" style="font-weight: normal; color: var(--gray); font-size: 0.9rem;">--</span>
        </div>
    </div>
</div>

                 

               </div>
            </div>
                
                <div class="tabs">
                    <div class="tab active" onclick="switchAnalysisTab('record')">Record Voice</div>
                    <div class="tab" onclick="switchAnalysisTab('upload')">Upload Audio</div>
                </div>
                
                <!-- Record Voice Section -->
                <div id="record-section" class="tab-content active">
                    <div class="voice-recorder">
                        <div class="visualizer" id="visualizer"></div>
                        
                        <div class="timer" id="timer">00:00</div>
                        
                        <p>Speak about how you're feeling or read a short passage with emotion (10-15 seconds recommended)</p>
                        
                        <div class="record-buttons">
                            <button class="record-btn" id="start-record">
                                <div class="icon"></div>
                            </button>
                            <button class="record-btn stop" id="stop-record" style="display: none;">
                                <div class="icon"></div>
                            </button>
                        </div>
                        
                        <div class="record-status" id="record-status">Click the button to start recording</div>
                        
                        <audio id="audio-player" class="audio-player" controls></audio>
                        
                        <button class="btn" id="analyze-record" disabled>Analyze My Voice</button>
                    </div>
                </div>
                
                <!-- Upload Audio Section -->
                <div id="upload-section" class="tab-content">
                    <div class="file-upload" id="file-drop-zone">
                        <label for="audio-file" class="file-label">Click to select an audio file or drag and drop</label>
                        <input type="file" id="audio-file" class="file-input" accept="audio/*">
                        <div class="file-name" id="file-name">No file selected</div>
                    </div>
                    
                    <div style="text-align: center;">
                        <button class="btn" id="analyze-file" disabled>Analyze Audio File</button>
                    </div>
                </div>
                
                <!-- Loading Indicator -->
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Analyzing your voice patterns...</p>
                </div>
                
                <!-- Results Section -->
                <div class="results" id="results">
                    <h3>Your Voice Analysis Results</h3>
                    
                    <div class="result-item">
                        <div class="result-label">Detected Emotion:</div>
                        <div id="emotion-result"></div>
                    </div>
                    
                    <div class="result-item">
                        <div class="result-label">Confidence:</div>
                        <div id="confidence-result"></div>
                    </div>
                    
                    <div class="result-item">
                        <div class="result-label">Stress Level:</div>
                        <div id="stress-result"></div>
                    </div>
                    
                    <!-- Face Emotion Results (shown if present) -->
                    <div class="result-item" id="face-emotion-result-item" style="display: none;">
                        <div class="result-label">Facial Emotion:</div>
                        <div id="face-emotion-result"></div>
                    </div>
                    
                    <!-- Wellness Data (shown if present) -->
                    <div id="wellness-results" style="display: none;">
                        <div class="result-item">
                            <div class="result-label">Wellness Index:</div>
                            <div id="wellness-index-result"></div>
                        </div>
                        <div class="result-item">
                            <div class="result-label">Overall Risk:</div>
                            <div id="risk-result"></div>
                        </div>
                        <div class="result-item" style="display: flex; flex-direction: column; gap: 5px;">
                            <div class="result-label">Risk Breakdown:</div>
                            <div style="display: flex; flex-direction: column; gap: 5px; margin-left: 0;">
                                <div>Audio Risk: <span id="audio-risk-result">–</span></div>
                                <div>Environmental Risk: <span id="env-risk-result">–</span></div>
                                <div>Physiological Risk: <span id="phys-risk-result">–</span></div>
                                <div>Facial Emotion Risk: <span id="face-risk-result">–</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="emotion-chart-container">
                        <canvas id="emotion-chart"></canvas>
                    </div>
                    
                    <div class="recommendation-box">
                        <div class="recommendation-title">Recommendation:</div>
                        <div id="recommendation-result"></div>
                    </div>
                    
                    <!-- Wellness Recommendation (shown if present) -->
                    <div class="recommendation-box" id="wellness-recommendation-box" style="display: none;">
                        <div class="recommendation-title">Wellness Recommendation:</div>
                        <div id="wellness-recommendation-result"></div>
                    </div>
                </div>
            </div>
            
            <!-- About Tab -->
            <div id="about-tab" class="tab-content">
                <h2 class="card-title">About StressBuster AI</h2>
                <p> The model has been trained on a dataset of audio recordings labeled with emotional states.</p>
                
                <h3 class="about-title">Detectable Emotions</h3>
                <div class="emotions-grid">
                    <div class="emotion-tag">Angry</div>
                    <div class="emotion-tag">Disgust</div>
                    <div class="emotion-tag">Fearful</div>
                    <div class="emotion-tag">Happy</div>
                    <div class="emotion-tag">Neutral</div>
                    <div class="emotion-tag">Sad</div>
                    <div class="emotion-tag">Surprised</div>
                </div>
                
                <h3 class="about-title">Model Performance</h3>
                <p>The model achieves high accuracy (91.99%), precision (92.3%), recall (91.99%), and F1 score (91.98%) on speech emotion recognition tasks. It has been trained on a balanced dataset containing hundreds of examples for each emotion category.</p>
                
                <h3 class="about-title">How It Works</h3>
                <p>When you upload or record audio, the application processes it through the Whisper model, which analyzes the audio features and predicts the emotional content. The model considers various aspects of speech including tone, pitch, rhythm, and other acoustic features to determine the most likely emotion.</p>
                
                <h3 class="about-title">Privacy & Data</h3>
                <p>Your voice recordings are processed on the server but are not permanently stored. If you create an account, your analysis results are stored to provide tracking and progress features, but the actual audio data is discarded after analysis.</p>
            </div>
        </div>

        <footer>
            <p>StressBuster AI</p>
        
        </footer>
    </div>

    <script>
        // cache latest sensors so analyzeRecording/analyzeFile can use them
let cachedSensors = null;


async function fetchSensors() {
  try {
    const res = await fetch('/sensors');
    const data = await res.json();
    cachedSensors = data || {};

    // Update UI
    document.getElementById('heartRate').textContent    = (cachedSensors.heart_rate ?? '–');
    document.getElementById('tempF').textContent  = (cachedSensors.temperature ?? '–');
    document.getElementById('light').textContent = (cachedSensors.light === 0 ? 'Dark' :
                                                           cachedSensors.light === 1 ? 'Light' : '–');
    document.getElementById('sound').textContent = (cachedSensors.sound_db ?? '–');
  } catch (e) {
    console.warn('fetchSensors failed', e);
  }
}

// start polling sensors every 3s
document.addEventListener('DOMContentLoaded', () => {
  fetchSensors();
  setInterval(fetchSensors, 3000);
});
        
        

        // DOM Elements
        let startRecordBtn, stopRecordBtn, analyzeRecordBtn, recordStatus;
        let timer, audioPlayer, visualizer, fileInput, fileName, analyzeFileBtn;
        let loading, results;
        let emotionChart = null;
        let emotionsTrendChart = null;
        let stressTrendChart = null;
        let topEmotionsChart = null;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Get all UI elements
            initializeElements();
            
            // Add event listeners
            setupEventListeners();
            
            // Check browser capabilities
            checkBrowserCapabilities();
            
            // Check if user is logged in
            checkAuthStatus();
            
            // Handle resize events for charts
            window.addEventListener('resize', function() {
                if (emotionChart) {
                    setTimeout(() => emotionChart.resize(), 100);
                }
                if (emotionsTrendChart) {
                    setTimeout(() => emotionsTrendChart.resize(), 100);
                }
                if (stressTrendChart) {
                    setTimeout(() => stressTrendChart.resize(), 100);
                }
                if (topEmotionsChart) {
                    setTimeout(() => topEmotionsChart.resize(), 100);
                }
            });
        });
        
        // Initialize UI elements
        function initializeElements() {
            startRecordBtn = document.getElementById('start-record');
            stopRecordBtn = document.getElementById('stop-record');
            analyzeRecordBtn = document.getElementById('analyze-record');
            recordStatus = document.getElementById('record-status');
            timer = document.getElementById('timer');
            audioPlayer = document.getElementById('audio-player');
            visualizer = document.getElementById('visualizer');
            fileInput = document.getElementById('audio-file');
            fileName = document.getElementById('file-name');
            analyzeFileBtn = document.getElementById('analyze-file');
            loading = document.getElementById('loading');
            results = document.getElementById('results');
            
            // Initialize canvas for visualization
            if (visualizer && !visualizer.querySelector('canvas')) {
                const canvas = document.createElement('canvas');
                canvas.width = visualizer.clientWidth || 600;
                canvas.height = visualizer.clientHeight || 80;
                visualizer.appendChild(canvas);
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            if (startRecordBtn) startRecordBtn.addEventListener('click', startRecording);
            if (stopRecordBtn) stopRecordBtn.addEventListener('click', stopRecording);
            if (analyzeRecordBtn) analyzeRecordBtn.addEventListener('click', analyzeRecording);
            if (fileInput) fileInput.addEventListener('change', handleFileInputChange);
            if (analyzeFileBtn) analyzeFileBtn.addEventListener('click', analyzeFile);
            
            // Auth form buttons
            document.getElementById('login-btn').addEventListener('click', handleLogin);
            document.getElementById('register-btn').addEventListener('click', handleRegister);
            document.getElementById('logout-btn').addEventListener('click', handleLogout);
            
            // Enable Enter key for login/register forms
            document.getElementById('login-password').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') handleLogin();
            });
            document.getElementById('register-password').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') handleRegister();
            });
            
            // Drag and drop functionality
            const dropZone = document.getElementById('file-drop-zone');
            if (dropZone) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, preventDefaults, false);
                });
                
                ['dragenter', 'dragover'].forEach(eventName => {
                    dropZone.addEventListener(eventName, () => dropZone.style.borderColor = '#6A67CE', false);
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, () => dropZone.style.borderColor = '#ccc', false);
                });
                
                dropZone.addEventListener('drop', handleDrop, false);
            }
        }
        
        // Tab Switching
        function switchTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tabs > .tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(`${tabId}-tab`).classList.add('active');
            
            // Add active class to selected tab
            document.querySelectorAll('.tabs > .tab').forEach(tab => {
                if (tab.textContent.toLowerCase().includes(tabId)) {
                    tab.classList.add('active');
                }
            });
        }
        
        // Switch between record and upload tabs
        function switchAnalysisTab(tabId) {
            if (tabId === 'record') {
                document.getElementById('record-section').classList.add('active');
                document.getElementById('upload-section').classList.remove('active');
                document.querySelectorAll('#analyze-tab .tabs .tab').forEach((tab, index) => {
                    tab.classList.toggle('active', index === 0);
                });
            } else {
                document.getElementById('record-section').classList.remove('active');
                document.getElementById('upload-section').classList.add('active');
                document.querySelectorAll('#analyze-tab .tabs .tab').forEach((tab, index) => {
                    tab.classList.toggle('active', index === 1);
                });
            }
        }
        
        // Toggle between login and register forms
        function toggleAuthForms() {
            const loginForm = document.getElementById('login-form');
            const registerForm = document.getElementById('register-form');
            
            if (loginForm.style.display === 'none') {
                loginForm.style.display = 'block';
                registerForm.style.display = 'none';
            } else {
                loginForm.style.display = 'none';
                registerForm.style.display = 'block';
            }
        }
        
        // Audio recording variables
        let mediaRecorder;
        let audioChunks = [];
        let recordingTimer;
        let seconds = 0;
        let audioBlob;
        
        // Start recording
        async function startRecording() {
            try {
                // Check if mediaDevices API is available (requires HTTPS or localhost)
                if (!navigator.mediaDevices) {
                    throw new Error("Media devices API is not available. Please use HTTPS or localhost.");
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Reset recording state
                audioChunks = [];
                seconds = 0;
                timer.textContent = '00:00';
                audioPlayer.style.display = 'none';
                results.style.display = 'none';
                
                // Setup media recorder with proper MIME type
                // Use a widely supported format
                const mimeType = MediaRecorder.isTypeSupported('audio/webm') 
                    ? 'audio/webm' 
                    : 'audio/mp4';
                
                mediaRecorder = new MediaRecorder(stream, { mimeType });
                
                // Setup visualization
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                // Get canvas context
                const canvas = visualizer.querySelector('canvas');
                const canvasCtx = canvas.getContext('2d');
                
                // Visualization function
                function draw() {
                    const drawVisual = requestAnimationFrame(draw);
                    
                    analyser.getByteFrequencyData(dataArray);
                    
                    canvasCtx.fillStyle = '#F5F5FA';
                    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = dataArray[i] / 255 * canvas.height;
                        
                        canvasCtx.fillStyle = `rgb(106, 103, 206)`;
                        canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth + 1;
                    }
                }
                
                draw();
                
                // Handle data available event
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                // Handle recording stopped
                mediaRecorder.onstop = () => {
                    // Create audio blob with correct MIME type
                    audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayer.src = audioUrl;
                    audioPlayer.style.display = 'block';
                    
                    stream.getTracks().forEach(track => track.stop());
                    
                    recordStatus.textContent = 'Recording completed. You can now analyze your voice.';
                    analyzeRecordBtn.disabled = false;
                    
                    console.log("Recording completed: ", audioBlob.size, "bytes");
                };
                
                // Start recording, collecting data every 100ms
                mediaRecorder.start(100);
                
                // Update UI
                startRecordBtn.style.display = 'none';
                stopRecordBtn.style.display = 'block';
                recordStatus.textContent = 'Recording... Speak with emotion or read a passage.';
                
                // Start timer
                recordingTimer = setInterval(() => {
                    seconds++;
                    const minutes = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    timer.textContent = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }, 1000);
                
            } catch (error) {
                console.error('Recording error:', error);
                recordStatus.textContent = `Error: ${error.message}`;
                
                // Show security warning for getUserMedia issues
                if (error.message.includes('Permission denied') || error.message.includes('not allowed')) {
                    recordStatus.textContent += '. Please ensure your microphone is connected and you have granted permission to use it.';
                } else if (error.message.includes('secure contexts') || error.message.includes('getUserMedia')) {
                    const securityWarning = document.getElementById('security-warning');
                    securityWarning.style.display = 'block';
                    securityWarning.innerHTML = '<strong>Browser Security Restriction:</strong> Voice recording requires HTTPS or localhost. Please use the Upload Audio option instead.';
                    
                    recordStatus.textContent = 'Voice recording requires secure connections (HTTPS) or localhost.';
                    
                    // Auto-switch to upload tab
                    switchAnalysisTab('upload');
                }
            }
        }
        
        // Stop recording
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                clearInterval(recordingTimer);
                
                // Update UI
                startRecordBtn.style.display = 'block';
                stopRecordBtn.style.display = 'none';
            }
        }
        
        // Analyze recording
        async function analyzeRecording() {
            if (!audioBlob || audioBlob.size === 0) {
                alert('No valid recording found. Please record your voice first.');
                return;
            }
            
            // Show loading, hide results
            loading.style.display = 'block';
            results.style.display = 'none';
            analyzeRecordBtn.disabled = true;
            
            try {
                // Create a new FormData object
                const formData = new FormData();
                
                // Convert blob to a file-like object with a proper name
                const audioFile = new File([audioBlob], "recording.webm", { 
                    type: audioBlob.type 
                });
                
                // Append the file to the FormData object
                formData.append('audio', audioFile);
                
                // Append sensors data if available
                if (cachedSensors) {
                    formData.append('sensor_json', JSON.stringify(cachedSensors));
                }
                
                console.log("Sending audio for analysis, size:", audioFile.size, "bytes, type:", audioFile.type);
                
                // Send to server
                const response = await fetch('/analyze', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Hide loading
                loading.style.display = 'none';
                
                if (data.error) {
                    console.error("Analysis error:", data.error);
                    alert(`Error: ${data.error}`);
                    analyzeRecordBtn.disabled = false;
                } else {
                    displayResults(data);
                }
            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while analyzing your voice: ' + error.message);
                loading.style.display = 'none';
                analyzeRecordBtn.disabled = false;
            }
        }
        
        // File input change event handler
        function handleFileInputChange() {
            if (fileInput.files.length > 0) {
                fileName.textContent = fileInput.files[0].name;
                analyzeFileBtn.disabled = false;
            } else {
                fileName.textContent = 'No file selected';
                analyzeFileBtn.disabled = true;
            }
        }
        
        // Analyze uploaded file
        async function analyzeFile() {
            if (!fileInput.files.length) {
                alert('Please select an audio file first.');
                return;
            }
            
            // Show loading, hide results
            loading.style.display = 'block';
            results.style.display = 'none';
            analyzeFileBtn.disabled = true;
            
            try {
                const formData = new FormData();
                formData.append('audio', fileInput.files[0]);
                
                // Append sensors data if available
                if (cachedSensors) {
                    formData.append('sensor_json', JSON.stringify(cachedSensors));
                }
                
                console.log("Sending uploaded file for analysis:", fileInput.files[0].name);
                
                const response = await fetch('/analyze', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Hide loading
                loading.style.display = 'none';
                
                if (data.error) {
                    alert(`Error: ${data.error}`);
                    analyzeFileBtn.disabled = false;
                } else {
                    displayResults(data);
                }
            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while analyzing your audio: ' + error.message);
                loading.style.display = 'none';
                analyzeFileBtn.disabled = false;
            }
        }
        
        // Display analysis results
        function displayResults(data) {
            // Update result elements
            document.getElementById('emotion-result').textContent = capitalizeFirstLetter(data.emotion);
            document.getElementById('confidence-result').textContent = data.confidence_str;
            
            const stressElement = document.getElementById('stress-result');
            stressElement.textContent = capitalizeFirstLetter(data.stress_level);
            
            // Style based on stress level
            stressElement.className = '';
            stressElement.classList.add(`stress-${data.stress_level}`);
            
            // Display recommendation
            document.getElementById('recommendation-result').textContent = data.recommendation;
            
            // Display face emotion data if present
            if (data.face_emotion) {
                const faceEmotionItem = document.getElementById('face-emotion-result-item');
                const faceEmotionResult = document.getElementById('face-emotion-result');
                
                if (data.face_emotion.label) {
                    const faceLabel = capitalizeFirstLetter(data.face_emotion.label);
                    const faceConfidence = data.face_emotion.confidence !== undefined 
                        ? `${(data.face_emotion.confidence * 100).toFixed(1)}%` 
                        : 'N/A';
                    faceEmotionResult.textContent = `${faceLabel} (${faceConfidence} confidence)`;
                } else {
                    faceEmotionResult.textContent = 'No face detected';
                }
                faceEmotionItem.style.display = 'flex';
            } else {
                document.getElementById('face-emotion-result-item').style.display = 'none';
            }
            
            // Display wellness data if present
            if (data.wellness_index !== undefined || data.risk !== undefined) {
                const wellnessResults = document.getElementById('wellness-results');
                
                if (data.wellness_index !== undefined) {
                    const wellnessIndexEl = document.getElementById('wellness-index-result');
                    wellnessIndexEl.textContent = `${data.wellness_index}/100`;
                    // Style based on wellness index
                    wellnessIndexEl.className = '';
                    if (data.wellness_index >= 70) {
                        wellnessIndexEl.classList.add('stress-low');
                    } else if (data.wellness_index >= 40) {
                        wellnessIndexEl.classList.add('stress-medium');
                    } else {
                        wellnessIndexEl.classList.add('stress-high');
                    }
                }
                
                if (data.risk !== undefined) {
                    document.getElementById('risk-result').textContent = data.risk.toFixed(3);
                }
                
                // Display risk breakdown if present
                if (data.audio_risk !== undefined) {
                    document.getElementById('audio-risk-result').textContent = data.audio_risk.toFixed(3);
                }
                if (data.env_risk !== undefined) {
                    document.getElementById('env-risk-result').textContent = data.env_risk.toFixed(3);
                }
                if (data.phys_risk !== undefined) {
                    document.getElementById('phys-risk-result').textContent = data.phys_risk.toFixed(3);
                }
                if (data.face_risk !== undefined) {
                    document.getElementById('face-risk-result').textContent = data.face_risk.toFixed(3);
                }
                
                wellnessResults.style.display = 'block';
            } else {
                document.getElementById('wellness-results').style.display = 'none';
            }
            
            // Display wellness recommendation if present
            if (data.wellness_recommendation) {
                document.getElementById('wellness-recommendation-result').textContent = data.wellness_recommendation;
                document.getElementById('wellness-recommendation-box').style.display = 'block';
            } else {
                document.getElementById('wellness-recommendation-box').style.display = 'none';
            }
            
            // Create/update emotion probability chart
            createEmotionChart(data.all_probabilities);
            
            // Show results
            results.style.display = 'block';
            
            // Re-enable buttons
            analyzeRecordBtn.disabled = false;
            analyzeFileBtn.disabled = false;
            
            // Scroll to results
            results.scrollIntoView({ behavior: 'smooth' });
        }
        
        // Create emotion probability chart
        function createEmotionChart(probabilities) {
            const ctx = document.getElementById('emotion-chart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (emotionChart) {
                emotionChart.destroy();
            }
            
            // Format data for Chart.js
            const emotions = Object.keys(probabilities).map(e => capitalizeFirstLetter(e));
            const values = Object.values(probabilities);
            
            // Define emotion colors
            const colors = {
                'Angry': '#F25767',     // Red
                'Disgust': '#9C27B0',   // Purple
                'Fearful': '#673AB7',   // Deep Purple
                'Happy': '#4CAF50',     // Green
                'Neutral': '#607D8B',   // Blue Grey
                'Sad': '#3F51B5',       // Indigo
                'Surprised': '#FF9800'  // Orange
            };
            
            // Get the backgroundColor array based on emotion names
            const backgroundColors = emotions.map(emotion => colors[emotion] || '#6A67CE');
            
            // Create the chart
            emotionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: emotions,
                    datasets: [{
                        label: 'Emotion Probability',
                        data: values,
                        backgroundColor: backgroundColors,
                        borderColor: backgroundColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            title: {
                                display: true,
                                text: 'Probability'
                            },
                            ticks: {
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Emotion'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Emotion Analysis Results',
                            font: {
                                size: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Probability: ${(context.raw * 100).toFixed(2)}%`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Create trends chart for progress tracking
        function createTrendCharts(emotionData, stressData, topEmotions) {
            // Prepare data for emotions trend chart
            const dates = Object.keys(emotionData).sort();
            const emotions = ['angry', 'disgust', 'fearful', 'happy', 'neutral', 'sad', 'surprised'];
            
            // Create datasets for each emotion
            const emotionDatasets = emotions.map(emotion => {
                const data = dates.map(date => {
                    return emotionData[date][emotion] || 0;
                });
                
                const color = getEmotionColor(emotion);
                
                return {
                    label: capitalizeFirstLetter(emotion),
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '33', // Add transparency
                    fill: false,
                    tension: 0.3
                };
            });
            
            // Create emotions trend chart
            const emotionsCtx = document.getElementById('emotions-trend-chart').getContext('2d');
            if (emotionsTrendChart) {
                emotionsTrendChart.destroy();
            }
            
            emotionsTrendChart = new Chart(emotionsCtx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: emotionDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Emotions Over Time',
                            font: { size: 16 }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        }
                    }
                }
            });
            
            // Prepare data for stress levels trend chart
            const stressLevels = ['high', 'medium', 'low'];
            
            const stressDatasets = stressLevels.map(level => {
                const data = dates.map(date => {
                    return stressData[date][level] || 0;
                });
                
                const color = getStressColor(level);
                
                return {
                    label: capitalizeFirstLetter(level),
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '33', // Add transparency
                    fill: true,
                    tension: 0.3
                };
            });
            
            // Create stress trend chart
            const stressCtx = document.getElementById('stress-trend-chart').getContext('2d');
            if (stressTrendChart) {
                stressTrendChart.destroy();
            }
            
            stressTrendChart = new Chart(stressCtx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: stressDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Stress Levels Over Time',
                            font: { size: 16 }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        }
                    }
                }
            });
            
            // Create top emotions chart
            const topEmotionsCtx = document.getElementById('top-emotions-chart').getContext('2d');
            if (topEmotionsChart) {
                topEmotionsChart.destroy();
            }
            
            // Prepare data for top emotions
            const topEmotionLabels = topEmotions.map(item => capitalizeFirstLetter(item.emotion));
            const topEmotionValues = topEmotions.map(item => item.count);
            const topEmotionColors = topEmotions.map(item => getEmotionColor(item.emotion));
            
            topEmotionsChart = new Chart(topEmotionsCtx, {
                type: 'bar',
                data: {
                    labels: topEmotionLabels,
                    datasets: [{
                        label: 'Frequency',
                        data: topEmotionValues,
                        backgroundColor: topEmotionColors,
                        borderColor: topEmotionColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Most Common Emotions',
                            font: { size: 16 }
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        }
                    }
                }
            });
        }
        
        // Get color for emotion
        function getEmotionColor(emotion) {
            const colors = {
                'angry': '#F25767',     // Red
                'disgust': '#9C27B0',   // Purple
                'fearful': '#673AB7',   // Deep Purple
                'happy': '#4CAF50',     // Green
                'neutral': '#607D8B',   // Blue Grey
                'sad': '#3F51B5',       // Indigo
                'surprised': '#FF9800'  // Orange
            };
            
            return colors[emotion] || '#6A67CE';
        }
        
        // Get color for stress level
        function getStressColor(level) {
            const colors = {
                'high': '#F25767',      // Red
                'medium': '#FFAB4C',    // Orange
                'low': '#39C4AC'        // Green
            };
            
            return colors[level] || '#6A67CE';
        }
        
        // Load user's progress statistics
        async function loadProgressStats(days) {
            try {
                // Update active filter button
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`.filter-btn:nth-child(${days === 7 ? 1 : days === 30 ? 2 : 3})`).classList.add('active');
                
                // Fetch stats from server
                const response = await fetch(`/user/stats?days=${days}`);
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // Create trend charts
                    createTrendCharts(
                        data.emotion_trends,
                        data.stress_trends,
                        data.top_emotions
                    );
                } else {
                    console.error('Error loading stats:', data.error);
                }
            } catch (error) {
                console.error('Error loading progress stats:', error);
            }
        }
        
        // Load user's history data
        async function loadHistoryData(offset = 0, limit = 10) {
            try {
                // Fetch history from server
                const response = await fetch(`/user/history?offset=${offset}&limit=${limit}`);
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    const tbody = document.getElementById('history-tbody');
                    tbody.innerHTML = '';
                    
                    // Add history items
                    data.records.forEach(record => {
                        const row = document.createElement('tr');
                        
                        // Format date
                        const date = new Date(record.created_at);
                        const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        
                        row.innerHTML = `
                            <td>${formattedDate}</td>
                            <td class="history-emotion">${capitalizeFirstLetter(record.emotion)}</td>
                            <td class="stress-${record.stress_level}">${capitalizeFirstLetter(record.stress_level)}</td>
                            <td>${(record.confidence * 100).toFixed(0)}%</td>
                        `;
                        
                        tbody.appendChild(row);
                    });
                    
                    // Create pagination
                    createPagination(data.total, limit, offset);
                } else {
                    console.error('Error loading history:', data.error);
                }
            } catch (error) {
                console.error('Error loading history data:', error);
            }
        }
        
        // Create pagination for history
        function createPagination(total, limit, currentOffset) {
            const pagination = document.getElementById('history-pagination');
            pagination.innerHTML = '';
            
            const pageCount = Math.ceil(total / limit);
            const currentPage = Math.floor(currentOffset / limit);
            
            // Previous button
            if (currentPage > 0) {
                const prevBtn = document.createElement('button');
                prevBtn.className = 'pagination-btn';
                prevBtn.textContent = '←';
                prevBtn.onclick = () => loadHistoryData((currentPage - 1) * limit, limit);
                pagination.appendChild(prevBtn);
            }
            
            // Page buttons
            const maxButtons = 5;
            const startPage = Math.max(0, Math.min(currentPage - Math.floor(maxButtons / 2), pageCount - maxButtons));
            const endPage = Math.min(pageCount, startPage + maxButtons);
            
            for (let i = startPage; i < endPage; i++) {
                const pageBtn = document.createElement('button');
                pageBtn.className = 'pagination-btn';
                if (i === currentPage) {
                    pageBtn.classList.add('active');
                }
                pageBtn.textContent = i + 1;
                pageBtn.onclick = () => loadHistoryData(i * limit, limit);
                pagination.appendChild(pageBtn);
            }
            
            // Next button
            if (currentPage < pageCount - 1) {
                const nextBtn = document.createElement('button');
                nextBtn.className = 'pagination-btn';
                nextBtn.textContent = '→';
                nextBtn.onclick = () => loadHistoryData((currentPage + 1) * limit, limit);
                pagination.appendChild(nextBtn);
            }
        }
        
        // Check if user is logged in
        function isLoggedIn() {
            return localStorage.getItem('user_id') !== null;
        }
        
        // Check authentication status
        function checkAuthStatus() {
            const userId = localStorage.getItem('user_id');
            const username = localStorage.getItem('username');
            const displayName = localStorage.getItem('display_name');
            
            if (userId && username) {
                // User is logged in
                updateUserHeader(displayName || username);
                
                // Show user profile, hide auth forms
                document.getElementById('user-profile').style.display = 'block';
                document.getElementById('login-form').style.display = 'none';
                document.getElementById('register-form').style.display = 'none';
                
                // Update profile info
                document.getElementById('profile-name').textContent = displayName || username;
                const avatar = document.getElementById('profile-avatar');
                avatar.textContent = (displayName || username).charAt(0).toUpperCase();
                
                // Load user data
                loadUserProfile();
            } else {
                // User is not logged in
                document.getElementById('user-header').style.display = 'none';
                
                // Show login form, hide user profile
                document.getElementById('user-profile').style.display = 'none';
                document.getElementById('login-form').style.display = 'block';
                document.getElementById('register-form').style.display = 'none';
            }
        }
        
        // Update user header
        function updateUserHeader(name) {
            const userHeader = document.getElementById('user-header');
            const userName = document.getElementById('user-name');
            const userAvatar = document.getElementById('user-avatar');
            
            userHeader.style.display = 'flex';
            userName.textContent = name;
            userAvatar.textContent = name.charAt(0).toUpperCase();
        }
        
        // Load user profile data
        async function loadUserProfile() {
            try {
                const response = await fetch('/user/profile');
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // Update profile info
                    if (data.profile.email) {
                        document.getElementById('profile-email').textContent = data.profile.email;
                    }
                    
                    const createdDate = new Date(data.profile.created_at);
                    document.getElementById('profile-joined').textContent = `Member since ${createdDate.toLocaleDateString()}`;
                    
                    // Update stats
                    document.getElementById('total-analyses').textContent = data.stats.total_records || '0';
                    
                    if (data.stats.last_record) {
                        const lastDate = new Date(data.stats.last_record);
                        document.getElementById('last-analysis').textContent = lastDate.toLocaleDateString();
                    } else {
                        document.getElementById('last-analysis').textContent = 'Never';
                    }
                } else {
                    console.error('Error loading profile:', data.error);
                }
            } catch (error) {
                console.error('Error loading user profile:', error);
            }
        }
        
        // Handle user login
        async function handleLogin() {
            const username = document.getElementById('login-username').value;
            const password = document.getElementById('login-password').value;
            const errorElement = document.getElementById('login-error');
            
            if (!username || !password) {
                errorElement.textContent = 'Please enter both username and password.';
                errorElement.style.display = 'block';
                return;
            }
            
            try {
                const response = await fetch('/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Clear form
                    document.getElementById('login-username').value = '';
                    document.getElementById('login-password').value = '';
                    errorElement.style.display = 'none';
                    
                    // Save user data to local storage
                    localStorage.setItem('user_id', data.user_id);
                    localStorage.setItem('username', data.username);
                    localStorage.setItem('display_name', data.display_name || data.username);
                    
                    // Update UI
                    updateUserHeader(data.display_name || data.username);
                    document.getElementById('user-profile').style.display = 'block';
                    document.getElementById('login-form').style.display = 'none';
                    
                    // Load user profile data
                    loadUserProfile();
                    
                    // If on login page, switch to analyze tab
                    switchTab('analyze');
                } else {
                    errorElement.textContent = data.error || 'Login failed. Please try again.';
                    errorElement.style.display = 'block';
                }
            } catch (error) {
                console.error('Login error:', error);
                errorElement.textContent = 'An error occurred during login. Please try again.';
                errorElement.style.display = 'block';
            }
        }
        
        // Handle user registration
        async function handleRegister() {
            const username = document.getElementById('register-username').value;
            const password = document.getElementById('register-password').value;
            const displayName = document.getElementById('register-name').value;
            const email = document.getElementById('register-email').value;
            const errorElement = document.getElementById('register-error');
            
            if (!username || !password) {
                errorElement.textContent = 'Please enter both username and password.';
                errorElement.style.display = 'block';
                return;
            }
            
            try {
                const response = await fetch('/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        username, 
                        password, 
                        display_name: displayName, 
                        email 
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Clear form
                    document.getElementById('register-username').value = '';
                    document.getElementById('register-password').value = '';
                    document.getElementById('register-name').value = '';
                    document.getElementById('register-email').value = '';
                    errorElement.style.display = 'none';
                    
                    // Save user data to local storage
                    localStorage.setItem('user_id', data.user_id);
                    localStorage.setItem('username', data.username);
                    localStorage.setItem('display_name', data.display_name || data.username);
                    
                    // Update UI
                    updateUserHeader(data.display_name || data.username);
                    document.getElementById('user-profile').style.display = 'block';
                    document.getElementById('register-form').style.display = 'none';
                    
                    // Load user profile data
                    loadUserProfile();
                    
                    // Switch to analyze tab
                    switchTab('analyze');
                } else {
                    errorElement.textContent = data.error || 'Registration failed. Please try again.';
                    errorElement.style.display = 'block';
                }
            } catch (error) {
                console.error('Registration error:', error);
                errorElement.textContent = 'An error occurred during registration. Please try again.';
                errorElement.style.display = 'block';
            }
        }
        
        // Handle user logout
        async function handleLogout() {
            try {
                const response = await fetch('/logout', {
                    method: 'POST'
                });
                
                // Clear local storage
                localStorage.removeItem('user_id');
                localStorage.removeItem('username');
                localStorage.removeItem('display_name');
                
                // Update UI
                document.getElementById('user-header').style.display = 'none';
                document.getElementById('user-profile').style.display = 'none';
                document.getElementById('login-form').style.display = 'block';
                
                // Reset forms
                document.getElementById('login-username').value = '';
                document.getElementById('login-password').value = '';
                document.getElementById('login-error').style.display = 'none';
            } catch (error) {
                console.error('Logout error:', error);
            }
        }
        
        // Utility functions
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0 && files[0].type.startsWith('audio/')) {
                fileInput.files = files;
                fileName.textContent = files[0].name;
                analyzeFileBtn.disabled = false;
            } else {
                alert('Please upload an audio file');
            }
        }
        
        // Check browser capabilities and show appropriate warnings
        function checkBrowserCapabilities() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                const securityWarning = document.getElementById('security-warning');
                securityWarning.style.display = 'block';
                securityWarning.innerHTML = '<strong>Browser Security Restriction:</strong> Voice recording requires secure connections (HTTPS) or localhost. Please use the Upload Audio option instead.';
                
                if (recordStatus) {
                    recordStatus.textContent = 'Voice recording requires secure connections (HTTPS) or localhost.';
                }
                
                // Auto-switch to upload tab
                switchAnalysisTab('upload');
                
                // Disable record button
                if (startRecordBtn) startRecordBtn.disabled = true;
            }
        }

        // Face detection variables
        let faceDetectionModel = null;
        let faceDetectionRunning = false;
        let faceDetectionAnimationFrame = null;

        // Initialize face detection model
        async function initFaceDetection() {
            try {
                // Check if blazeface is available
                if (typeof blazeface === 'undefined') {
                    console.warn("[Face Detection] BlazeFace library not loaded, trying alternative...");
                    // Try loading from alternative CDN
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@2.0.5';
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                }
                
                console.log("[Face Detection] Loading BlazeFace model...");
                if (typeof blazeface !== 'undefined') {
                    faceDetectionModel = await blazeface.load();
                    console.log("[Face Detection] BlazeFace model loaded successfully");
                    return true;
                } else {
                    throw new Error("BlazeFace not available");
                }
            } catch (error) {
                console.error("[Face Detection] Failed to load BlazeFace model:", error);
                console.log("[Face Detection] Continuing without browser face detection - backend detection will still work");
                return false;
            }
        }

        // Detect faces and draw squares
        async function detectFaces() {
            const video = document.getElementById("camera-stream");
            const canvas = document.getElementById("face-detection-canvas");
            const statusEl = document.getElementById("face-detection-status");
            
            if (!video || !canvas || !faceDetectionModel || video.readyState !== 4) {
                return;
            }

            try {
                // Detect faces
                const predictions = await faceDetectionModel.estimateFaces(video, false);
                
                const ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (predictions.length > 0) {
                    // Show status
                    if (statusEl) {
                        statusEl.style.display = "block";
                    }
                    
                    // Draw squares around detected faces
                    predictions.forEach(prediction => {
                        const start = prediction.topLeft;
                        const end = prediction.bottomRight;
                        const size = [end[0] - start[0], end[1] - start[1]];
                        
                        // Draw square
                        ctx.strokeStyle = "#6a67ce";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(start[0], start[1], size[0], size[1]);
                        
                        // Draw corner indicators for better visibility
                        const cornerSize = 15;
                        ctx.fillStyle = "#6a67ce";
                        
                        // Top-left corner
                        ctx.fillRect(start[0] - 2, start[1] - 2, cornerSize, 3);
                        ctx.fillRect(start[0] - 2, start[1] - 2, 3, cornerSize);
                        
                        // Top-right corner
                        ctx.fillRect(end[0] - cornerSize + 2, start[1] - 2, cornerSize, 3);
                        ctx.fillRect(end[0] - 2, start[1] - 2, 3, cornerSize);
                        
                        // Bottom-left corner
                        ctx.fillRect(start[0] - 2, end[1] - 2, cornerSize, 3);
                        ctx.fillRect(start[0] - 2, end[1] - cornerSize + 2, 3, cornerSize);
                        
                        // Bottom-right corner
                        ctx.fillRect(end[0] - cornerSize + 2, end[1] - 2, cornerSize, 3);
                        ctx.fillRect(end[0] - 2, end[1] - cornerSize + 2, 3, cornerSize);
                    });
                } else {
                    // Hide status if no face detected
                    if (statusEl) {
                        statusEl.style.display = "none";
                    }
                }
            } catch (error) {
                console.error("[Face Detection] Detection error:", error);
            }
            
            // Continue detection loop
            if (faceDetectionRunning) {
                faceDetectionAnimationFrame = requestAnimationFrame(detectFaces);
            }
        }

        // Start face detection loop
        function startFaceDetection() {
            if (faceDetectionRunning) {
                return;
            }
            
            if (!faceDetectionModel) {
                console.warn("[Face Detection] Model not loaded yet");
                return;
            }
            
            faceDetectionRunning = true;
            console.log("[Face Detection] Starting face detection loop");
            detectFaces();
        }

        // Stop face detection loop
        function stopFaceDetection() {
            faceDetectionRunning = false;
            if (faceDetectionAnimationFrame) {
                cancelAnimationFrame(faceDetectionAnimationFrame);
                faceDetectionAnimationFrame = null;
            }
            // Clear canvas
            const canvas = document.getElementById("face-detection-canvas");
            if (canvas) {
                const ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            const statusEl = document.getElementById("face-detection-status");
            if (statusEl) {
                statusEl.style.display = "none";
            }
        }

        function startCamera() {
            const video = document.getElementById("camera-stream");
            
            if (!video) {
                console.warn("Camera video element not found");
                return;
            }

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 640 },
                        facingMode: "user"
                    } 
                })
                    .then(async stream => {
                        video.srcObject = stream;
                        await video.play();
                        console.log("[Camera] Camera started successfully");
                        
                        // Wait for video to be ready, then start face detection
                        video.addEventListener('loadedmetadata', () => {
                            console.log("[Camera] Video metadata loaded");
                            if (faceDetectionModel) {
                                startFaceDetection();
                            }
                        }, { once: true });
                    })
                    .catch(err => {
                        console.error("[Camera] Camera access blocked:", err);
                        const labelEl = document.getElementById("face-emotion-label");
                        if (labelEl) {
                            labelEl.textContent = "Camera access denied";
                        }
                    });
            } else {
                console.warn("[Camera] Your browser does not support camera access.");
            }
        }

function fetchFaceEmotion() {
    const labelEl = document.getElementById("face-emotion-label");
    const confidenceEl = document.getElementById("face-emotion-confidence");
    const tsEl = document.getElementById("face-emotion-ts");
    
    if (!labelEl || !confidenceEl || !tsEl) {
        console.warn("Face emotion elements not found, retrying...");
        return;
    }
    
    fetch("/face-emotion")
        .then(res => {
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}`);
            }
            return res.json();
        })
        .then(data => {
            // Update emotion label
            if (data.label && data.label !== "null" && data.label !== null && data.label.trim() !== "") {
                labelEl.textContent = data.label.charAt(0).toUpperCase() + data.label.slice(1);
                labelEl.style.color = "var(--primary)";
            } else {
                labelEl.textContent = "No Face";
                labelEl.style.color = "var(--gray)";
            }

            // Update confidence as percentage
            if (data.confidence !== undefined && data.confidence !== null && data.confidence > 0) {
                const confidencePercent = (data.confidence * 100).toFixed(1);
                confidenceEl.textContent = confidencePercent + "%";
                confidenceEl.style.color = "var(--secondary)";
            } else {
                confidenceEl.textContent = "--";
                confidenceEl.style.color = "var(--gray)";
            }

            // Update timestamp
            if (data.ts) {
                try {
                    const date = new Date(data.ts);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffSec = Math.floor(diffMs / 1000);
                    
                    if (diffSec < 5) {
                        tsEl.textContent = "Just now";
                    } else if (diffSec < 60) {
                        tsEl.textContent = diffSec + "s ago";
                    } else {
                        const diffMin = Math.floor(diffSec / 60);
                        tsEl.textContent = diffMin + "m ago";
                    }
                } catch (e) {
                    tsEl.textContent = data.ts || "--";
                }
            } else {
                tsEl.textContent = "--";
            }
        })
        .catch(err => {
            console.error("Face emotion fetch error:", err);
            // Show error state
            if (labelEl) labelEl.textContent = "Error";
            if (confidenceEl) confidenceEl.textContent = "--";
            if (tsEl) tsEl.textContent = "--";
        });
}

function triggerBackendFaceScan() {
    console.log("[Face Detection] Triggering backend face scan...");
    fetch("/capture-face")
        .then(res => {
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            return res.json();
        })
        .then(data => {
            console.log("[Face Detection] Backend response:", data);
            if (data.error) {
                console.warn("[Face Detection] Error:", data.error);
                // Update UI to show error state
                const labelEl = document.getElementById("face-emotion-label");
                if (labelEl) {
                    if (data.error.includes("no face")) {
                        labelEl.textContent = "No Face Detected";
                        labelEl.style.color = "var(--gray)";
                    } else if (data.error.includes("camera")) {
                        labelEl.textContent = "Camera Error";
                        labelEl.style.color = "var(--danger)";
                    } else if (data.error.includes("model")) {
                        labelEl.textContent = "Model Error";
                        labelEl.style.color = "var(--danger)";
                    } else {
                        labelEl.textContent = "Detection Error";
                        labelEl.style.color = "var(--danger)";
                    }
                }
            } else if (data.label && data.label !== "null" && data.label !== null) {
                console.log("[Face Detection] Face captured successfully:", data.label, "confidence:", data.confidence);
                // Immediately update UI with fresh data
                fetchFaceEmotion();
            } else {
                console.log("[Face Detection] No face detected in response");
            }
        })
        .catch(err => {
            console.error("[Face Detection] Backend capture error:", err);
            const labelEl = document.getElementById("face-emotion-label");
            if (labelEl) {
                labelEl.textContent = "Connection Error";
                labelEl.style.color = "var(--danger)";
            }
        });
}

// Initialize camera and face detection when DOM is ready
let faceDetectionInterval = null;
let faceFetchInterval = null;

async function initializeFaceDetection() {
    console.log("[Init] Initializing face detection system...");
    
    // Initialize browser-based face detection model
    const modelLoaded = await initFaceDetection();
    if (!modelLoaded) {
        console.warn("[Init] Browser face detection model failed to load, continuing with backend only");
    }
    
    // Start camera for preview
    startCamera();
    
    // Wait a bit for camera to initialize, then start detection
    setTimeout(() => {
        // Start triggering backend face scans every 2 seconds (backend needs time to process)
        triggerBackendFaceScan(); // Initial call
        faceDetectionInterval = setInterval(triggerBackendFaceScan, 2000);
        
        // Start fetching face emotion data every 1 second (faster than capture for smooth updates)
        fetchFaceEmotion(); // Initial call
        faceFetchInterval = setInterval(fetchFaceEmotion, 1000);
        
        console.log("[Init] Face detection initialized - browser detection: " + (modelLoaded ? "active" : "disabled") + ", backend scanning every 2s, fetching every 1s");
    }, 1000);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeFaceDetection);
} else {
    // DOM is already ready
    initializeFaceDetection();
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    stopFaceDetection();
    if (faceDetectionInterval) clearInterval(faceDetectionInterval);
    if (faceFetchInterval) clearInterval(faceFetchInterval);
}); 
    </script>
</body>
</html>
